# Generated by Django 2.1.5 on 2019-04-04 14:27

import sys

from django.conf import settings
from django.db import migrations

from data_refinery_common.utils import get_env_variable

# We want this to throw if it can't access this, no point in running a
# migration to set everything to a bad value.
S3_QN_TARGET_BUCKET_NAME = get_env_variable("S3_QN_TARGET_BUCKET_NAME")


def update_qn_bucket(apps, schema_editor):
    """Sets the s3_bucket for QN Targets to a bucket just for them.

    Based off of:
    https://simpleisbetterthancomplex.com/tutorial/2017/09/26/how-to-create-django-data-migrations.html

    We can't import the ComputedFile model directly as it may be a newer
    version than this migration expects. We use the historical version.
    """

    if not settings.RUNNING_IN_CLOUD:
        return

    # Pagination isn't necessary here because we have very few QN targets.
    ComputedFile = apps.get_model("data_refinery_common", "ComputedFile")
    for computed_file in ComputedFile.objects.filter(is_qn_target=True):
        if not computed_file.s3_bucket or not computed_file.s3_key:
            continue

        if not computed_file.change_s3_location(S3_QN_TARGET_BUCKET_NAME, computed_file.s3_key):
            # The call to change_s3_location will already logs what
            # went wrong, so we don't need to log. If there's any kind
            # of network/AWS issue going on all we really need to do
            # is stop the migration from finishing successfully since
            # once a migration completes successfully it won't ever be
            # run again.
            sys.exit(1)


class Migration(migrations.Migration):

    dependencies = [
        ("data_refinery_common", "0019_sample_is_blacklisted"),
    ]

    operations = [
        migrations.RunPython(update_qn_bucket),
    ]
